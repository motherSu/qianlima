package concurrent;

import java.util.concurrent.CountDownLatch;
/*
 * 一个把变量自增100次的例子，只不过用了4个线程，每个线程自增25次，用CountDownLatch等4个线程执行完，打印出最终结果。实际上，我们希望程序的结果是100，但是打印出来的结果并非总是100。

    这就引出了线程安全所描述的问题，我们先用通俗的话来描述一下线程安全：

    线程安全就是要让程序运行出我们想要的结果，或者话句话说，让程序像我们看到的那样执行。

    解释一下我总结的这句话，我们先new出了一个add对象，调用了对象的doAdd方法，本来我们希望每个线程有序的自增25次，最终得到正确的结果。如果程序增的像我们预先设定的那样运行，那么这个对象就是线程安全的。
    
    Brian Goetz对线程安全的描述：
    当多线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替，也不需要进行额外的同步，
    或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。
    
    Java虚拟机运行时内存的区域划分

    方法区：存储类信息、常量、静态变量等，各线程共享

    虚拟机栈：每个方法的执行都会创建栈帧，用于存储局部变量、操作数栈、动态链接等，虚拟机栈主要存储这些信息，线程私有

    本地方法栈：虚拟机使用到的Native方法服务，例如c程序等，线程私有

    程序计数器：记录程序运行到哪一行了，相当于当前线程字节码的行号计数器，线程私有

    堆：new出的实例对象都存储在这个区域，是GC的主战场，线程共享。

    所以对于JMM定义的主内存，大部分时候可以对应堆内存、方法区等线程共享的区域，这里只是概念上对应，其实程序计数器、虚拟机栈等也有部分是放在主内存的，具体看虚拟机的设计。
    
    
    造成这个错误的本质原因：

    （1）、可见性，工作内存的最新值不知道什么时候会写回主内存

    （2）、有序性，线程之间必须是有序的访问共享变量，我们用“视界”这个概念来描述一下这个过程，
    	以B线程的视角看，	当他看到A线程运算好之后，把值写回之内存之后，马上去读取最新的值来做运算。
    	A线程也应该是看到B运算完之后，马上去读取，在做运算，这样就得到了正确的结果。
 */
public class Add {

	//private int count = 0;
	// 给count加上volatile关键字，就保证了可见性。
	/*
	 * volatile关键字，会在最终编译出来的指令上加上lock前缀，lock前缀的指令做三件事情

    （1）、防止指令重排序（这里对本问题的分析不重要，后面会详细来讲）

    （2）、锁住总线或者使用锁定缓存来保证执行的原子性，早期的处理可能用锁定总线的方式，这样其他处理器没办法通过总线访问内存，开销比较大，现在的处理器都是用锁定缓存的方式，在配合缓存一致性来解决。

    （3）、把缓冲区的所有数据都写回主内存，并保证其他处理器缓存的该变量失效

    既然保证了可见性，加上了volatile关键词，为什么还是无法得到正确的结果，原因是count++，并非原子操作，count++等效于如下步骤：

   （1）、 从主内存中读取count赋值给线程副本变量：

            temp=count

    （2）、线程副本变量加1

            temp=temp+1

    （3）、线程副本变量写回主内存

            count=temp

    就算是真的严苛的给总线加锁，导致同一时刻，只能有一个处理器访问到count变量，但是在执行第（2）步操作时，其他cpu已经可以访问count变量，此时最新运算结果还没刷回主内存，造成了错误的结果，所以必须保证顺序性。

    那么保证顺序性的本质，就是保证同一时刻只有一个CPU可以执行临界区代码。这时候做法通常是加锁，锁本质是分两种：悲观锁和乐观锁。如典型的悲观锁synchronized、JUC包下面典型的乐观锁ReentrantLock。

    总结一下：要保证线程安全，必须保证两点：共享变量的可见性、临界区代码访问的顺序性。
    
    
    1、主内存与工作内存交互协议

    JMM定义了8种基本操作来完成，主内存、工作内存和执行引擎之间的交互，分别是lock、unlock、read、load、use、assign、store、write，虚拟机的实现向程序员保证每一种操作都是原子的，不可分割，对于double和long类型的64为变量不做保证。了解了这些，有助于帮我们理解内存屏障。

    别看有8个操作，实际上是成对定义的连贯操作。我们具体来看怎么记忆。

    （1）、针对于主内存的单独操作lock和unlock

    lock：作用于主内存、把变量标示为线程独占

    unlock：作用于主内存、释放锁定状态

    （2）、主内存到工作内存的读交换

    read：作用于主内存，把主内存变量传递给工作内存

    load：作用于工作内存，把read操作传过来的值放入工作内存

    （3）、工作内存到主内存的写交换

    store：作用于工作内存，把工作内存变量传递给主内存

    write：作用于主内存，把store过来的值写入主内存变量

    （4）、工作内存和执行引擎的数据交换

    use：作用于工作内存，把工作内存变量传递给执行引擎

    assign：作用于工作内存，把执行引擎的值赋给工作内存变量
    
    
    （1）、read和load、store和write必须同时出现‘

    （2）、对变量执行lock操作，会清空工作内存中缓存的该值，对变量执行unlock操作，必须先把值同步回主内存。
	 */
	private volatile int count = 0;

	public static void main(String[] args) {
		CountDownLatch countDownLatch = new CountDownLatch(4);
		Add add = new Add();
		add.doAdd(countDownLatch);
		try {
			countDownLatch.await();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(add.getCount());

	}
	public void doAdd(final CountDownLatch countDownLatch) {
		for (int i = 0; i < 4; i++) {
			new Thread(new Runnable() {
				public void run() {
					for (int j = 0; j < 2500; j++) {
						count++;
					}
					countDownLatch.countDown();
				}
			}).start();
		}
	}

	public int getCount() {
		return count;
	}
}
